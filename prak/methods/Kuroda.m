function result = Kuroda(Az, u, v, epsilon = 0.01, maxim = 5000)itt = 0;Az(Az == 0) = 0.01;M = 1000000;# Initializationk = length(Az);Z = eye(k);lambd = zeros(k, 1);tau = zeros(1, k);# Sums of rows, columnsu0 = sum(Az, 2);v0 = sum(Az, 1);u(u == 0) = k * 0.01;v(v == 0) = k * 0.01;# Weights for Kuroda 1 (good)W = (u0 .^ 2) ./ (Az .^ 2);V = (v0 .^ 2) ./ (Az .^ 2);#Weights for Kuroda 2 #W = (u .^ 2) / 2;#V = (v .^ 2) / 2;# Weights for Kuroda 3 (simple)#W = ones(k);#V = ones(k);# Supporting variablesS = W ./ (u .^ 2) + V ./ (v .^ 2);S0 = W ./ (u0 .* u) + V ./ (v0 .* v);coef = Az .* (S0 ./ S);Sinv = S .^ -1;    do    lambd0 = lambd;    tau0 = tau;        # Prevent negative numbers    neg = M * Az .* min(0, Z);         # Lambdas & taus    lambd = (u - sum(coef - neg + tau ./ S, 2)) ./ sum(Sinv, 2);    tau = (v - sum(coef - neg + lambd ./ S, 1)) ./ sum(Sinv, 1);        # Z    Z = ifelse(S == 0, 0, (S0 + (lambd .* ones(1, k) + tau .* ones(k, 1)) ./ Az) ./ S);    Z(Az == 0) = 1;    Z = ifelse(Z >= 0, Z, Z / (1 + M));        diffLambd = abs(lambd .- lambd0);    diffTau = abs(tau .-tau0);    itt += 1;      until(or(        and(all(diffLambd < epsilon),            all(diffTau < epsilon)),        itt > maxim))    X = Z .* Az;  result = round(X);  endfunction
