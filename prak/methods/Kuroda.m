function result = Kuroda(Az, u, v, variant = 1, epsilon = 0.01, maxim = 10000)% PURPOSE: estimate a new matrix X on the base of X0 with exogenously% given row and column totals.% -------------------------------------------------------------------------% USAGE: X = Kuroda(X0,u,v) with or without epsilon and maxim% included as the five argument, where% INPUT:% -> Az = benchmark (base) matrix, not necessarily square% -> u = row vector of row totals% -> v = column vector of column totals% -> variant = variant of method; if empty, the default is 1 (Kuroda 1)% -> epsilon = convergence tolerance level; if empty, the default threshold% is 0.01% -> maxim = maximum itterations before algorithm stops, if empty, the default% limit is 10.000 itterations% OUTPUT:% -> result = estimated/adjusted/updated matrixitt = 0;Az(Az == 0) = 0.01;M = 1000000;# Initializationk = length(Az);Z = eye(k);lambd = zeros(k, 1);tau = zeros(1, k);# Sums of rows, columnsu0 = sum(Az, 2);v0 = sum(Az, 1);u(u == 0) = k * 0.01;v(v == 0) = k * 0.01;switch variant   case 1    # Weights for Kuroda 1     W = (u0 ./ Az) .^ 2;    V = (v0 ./ Az) .^ 2;  case 2    #Weights for Kuroda 2     W = (u .^ 2) / 2;    V = (v .^ 2) / 2;  otherwise    # Weights for Kuroda 3     W = ones(k);    V = ones(k);end# Supporting variablesS = W ./ (u .^ 2) + V ./ (v .^ 2);S0 = W ./ (u0 .* u) + V ./ (v0 .* v);coef = Az .* (S0 ./ S);Sinv = S .^ -1;    do    lambd0 = lambd;    tau0 = tau;        # Prevent negative numbers    neg = M * Az .* min(0, Z);         # Coefficients of the differences between real sums of rows/columns and estimated    lambd = (u - sum(coef - neg + tau ./ S, 2)) ./ sum(Sinv, 2);    tau = (v - sum(coef - neg + lambd ./ S, 1)) ./ sum(Sinv, 1);        # Z    Z = ifelse(S == 0, 0,(S0 + (lambd .* ones(1, k) + tau .* ones(k, 1)) ./ Az) ./ S);    Z = ifelse(Z >= 0, Z, Z / (1 + M));        # Calculate residual between coefficients of the columns and rows sums differenses    diffLambd = abs(lambd .- lambd0);    diffTau = abs(tau .-tau0);    itt += 1;      until(or(        and(all(diffLambd < epsilon),            all(diffTau < epsilon)),        itt > maxim)) # working until both columns and rows coefficients are less than epsilon, or limit is reached      # Get estimated matrix      X = Z .* Az;  result = X;  endfunction